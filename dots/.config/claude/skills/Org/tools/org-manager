#!/usr/bin/env bash
# org-manager - CLI tool for org-mode file manipulation via Emacs batch mode
# Copyright (C) 2025 Vincent Demeester
# Part of Claude Code Org skill

set -euo pipefail

# Configuration
# Resolve symlinks to get actual script location
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
BATCH_FUNCTIONS="${BATCH_FUNCTIONS:-$SCRIPT_DIR/batch-functions.el}"
DENOTE_FUNCTIONS="${DENOTE_FUNCTIONS:-$SCRIPT_DIR/denote-batch-functions.el}"
EMACS="${EMACS:-emacs}"

# Debug mode
DEBUG="${DEBUG:-0}"

# Colors for output (if not outputting JSON)
if [[ -t 1 ]] && [[ "${JSON_OUTPUT:-1}" != "1" ]]; then
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
    NC='\033[0m' # No Color
else
    RED=''
    YELLOW=''
    NC=''
fi

# Error handling
error() {
    echo -e "${RED}Error: $*${NC}" >&2
    exit 1
}

debug() {
    if [[ "$DEBUG" == "1" ]]; then
        echo -e "${YELLOW}Debug: $*${NC}" >&2
    fi
}

# Check dependencies
check_deps() {
    if ! command -v "$EMACS" &> /dev/null; then
        error "Emacs not found. Set EMACS environment variable or install emacs."
    fi

    if [[ ! -f "$BATCH_FUNCTIONS" ]]; then
        error "batch-functions.el not found at: $BATCH_FUNCTIONS"
    fi

    if [[ ! -f "$DENOTE_FUNCTIONS" ]]; then
        error "denote-batch-functions.el not found at: $DENOTE_FUNCTIONS"
    fi
}

# Run Emacs in batch mode
run_elisp() {
    local elisp_code="$1"

    debug "Running elisp: $elisp_code"

    if [[ "$DEBUG" == "1" ]]; then
        "$EMACS" --batch --no-init-file \
            --load "$BATCH_FUNCTIONS" \
            --eval "$elisp_code" 2>&1
    else
        "$EMACS" --batch --no-init-file \
            --load "$BATCH_FUNCTIONS" \
            --eval "$elisp_code" 2>/dev/null
    fi
}

# Run Emacs in batch mode with denote functions
run_denote_elisp() {
    local elisp_code="$1"

    debug "Running denote elisp: $elisp_code"

    if [[ "$DEBUG" == "1" ]]; then
        "$EMACS" --batch --no-init-file \
            --load "$DENOTE_FUNCTIONS" \
            --eval "$elisp_code" 2>&1
    else
        "$EMACS" --batch --no-init-file \
            --load "$DENOTE_FUNCTIONS" \
            --eval "$elisp_code" 2>/dev/null
    fi
}

# Usage information
usage() {
    cat <<EOF
org-manager - Org-mode file manipulation tool

Usage: org-manager <command> <file> [options]

READ COMMANDS:
  list <file> [--state=STATE] [--priority=N] [--tags=TAG1,TAG2]
      List TODO items with optional filters

  scheduled <file> [--date=YYYY-MM-DD|today]
      Get items scheduled for date (default: today)

  count <file> [--state=STATE]
      Count TODO items by state

  search <file> <term>
      Search for term in file

  by-section <file> <section>
      Get TODOs in specific section

  sections <file>
      List all top-level sections

  children <file> <heading>
      Get direct children of a specific heading

  get <file> <heading>
      Get full content and metadata of a specific TODO
      Returns heading, state, priority, tags, scheduled, deadline, properties, and body content

  overdue <file>
      Get all tasks with deadlines before today
      Only shows active TODOs (excludes DONE/CANX)

  upcoming <file> [--days=N]
      Get tasks scheduled or due in next N days (default: 7)
      Shows tasks with SCHEDULED or DEADLINE dates in range

WRITE COMMANDS:
  add <file> <heading> --section=NAME [--scheduled=DATE] [--priority=N] [--tags=TAG1,TAG2]
      Add new TODO item

  update-state <file> <heading> <new-state>
      Change TODO state (NEXT, STRT, TODO, WAIT, DONE, CANX)

  schedule <file> <heading> <date>
      Set SCHEDULED date (YYYY-MM-DD)

  deadline <file> <heading> <date>
      Set DEADLINE date (YYYY-MM-DD)

  priority <file> <heading> <priority>
      Set priority (1-5)

  archive <file>
      Archive all DONE and CANX items

TAG MANAGEMENT:
  add-tags <file> <heading> <tags>
      Add tags to existing TODO (comma-separated, e.g., work,urgent)

  remove-tags <file> <heading> <tags>
      Remove specific tags from TODO (comma-separated)

  replace-tags <file> <heading> <tags>
      Replace all tags on TODO with new set (comma-separated)

  list-tags <file>
      List all unique tags used in file

PROPERTY OPERATIONS:
  get-property <file> <heading> <property>
      Get value of a specific property

  set-property <file> <heading> <property> <value>
      Set property value

  list-properties <file> <heading>
      List all properties of a heading

DENOTE COMMANDS:
  denote-create <title> <tags> [--signature=SIG] [--category=CAT] [--directory=DIR] [--content=FILE]
      Create a denote-formatted note with proper naming and frontmatter
      Tags: comma-separated list (e.g., nixos,homelab,plan)

  denote-append <filepath> <content-file>
      Append content to existing denote note

  denote-metadata <filepath>
      Read metadata from denote note

  denote-update <filepath> [--title=TITLE] [--tags=TAGS] [--category=CAT]
      Update denote note frontmatter

OPTIONS:
  --state=STATE         Filter by TODO state
  --priority=N          Filter by priority (1-5) or list: 1,2
  --tags=TAG1,TAG2      Filter by tags (match any)
  --date=YYYY-MM-DD     Specific date (or 'today')
  --section=NAME        Section name for new items
  --scheduled=DATE      Schedule date for new items

ENVIRONMENT:
  EMACS                 Path to emacs binary (default: emacs)
  BATCH_FUNCTIONS       Path to batch-functions.el
  DEBUG                 Enable debug output (1 or 0)

EXAMPLES:
  # List NEXT tasks
  org-manager list ~/desktop/org/todos.org --state=NEXT

  # Add high-priority task
  org-manager add ~/desktop/org/todos.org "Review PR" \\
    --section=Work --priority=2 --scheduled=2025-12-10

  # Mark task done
  org-manager update-state ~/desktop/org/todos.org "Review PR" DONE

  # Get today's schedule
  org-manager scheduled ~/desktop/org/todos.org

  # Count by state
  org-manager count ~/desktop/org/todos.org

  # Get children of a heading
  org-manager children ~/desktop/org/todos.org "Migrate aion"

  # Get full content of a TODO
  org-manager get ~/desktop/org/todos.org "Review PR"

  # Create denote note
  org-manager denote-create "NixOS Refactoring Plan" "nixos,refactoring,plan" \\
    --category=homelab --directory=~/desktop/org/notes

  # Create automated note with signature
  org-manager denote-create "Session Summary" "history,session" \\
    --signature=pkai --category=history

  # Read note metadata
  org-manager denote-metadata ~/desktop/org/notes/20251205T*.org

OUTPUT:
  All commands return JSON for easy parsing:
  {"success": true, "data": [...]}
  {"success": false, "error": "message"}

EXIT CODES:
  0    Success
  1    General error
  2    File not found
  3    Invalid arguments

EOF
    exit 0
}

# Parse arguments helper
parse_option() {
    local arg="$1"
    local prefix="$2"
    echo "${arg#"$prefix"}"
}

# Commands

cmd_list() {
    local file="$1"; shift
    local state="" priority="" tags=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --state=*)
                state=$(parse_option "$1" "--state=")
                shift
                ;;
            --priority=*)
                priority=$(parse_option "$1" "--priority=")
                shift
                ;;
            --tags=*)
                tags=$(parse_option "$1" "--tags=")
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp
    elisp="(progn
      (let ((result (org-batch-list-todos \"$file\"
                      $([ -n "$state" ] && echo "\"$state\"" || echo "nil")
                      $([ -n "$priority" ] && echo "'($priority)" || echo "nil")
                      $([ -n "$tags" ] && echo "'(${tags//,/\" \"})" || echo "nil"))))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_scheduled() {
    local file="$1"; shift
    local date="today"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --date=*)
                date=$(parse_option "$1" "--date=")
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp="(progn
      (let ((result (org-batch-scheduled-today \"$file\" \"$date\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_count() {
    local file="$1"; shift

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp="(progn
      (let ((result (org-batch-count-by-state \"$file\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_search() {
    local file="$1"
    local term="$2"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$term" ]] || error "Search term required"

    local elisp="(progn
      (let ((result (org-batch-search \"$file\" \"$term\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_by_section() {
    local file="$1"
    local section="$2"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$section" ]] || error "Section name required"

    local elisp="(progn
      (let ((result (org-batch-by-section \"$file\" \"$section\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_sections() {
    local file="$1"

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp="(progn
      (let ((result (org-batch-get-sections \"$file\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_children() {
    local file="$1"
    local heading="$2"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading name required"

    # Escape double quotes in heading for elisp string
    local heading_escaped="${heading//\"/\\\"}"

    local elisp="(progn
      (let ((result (org-batch-get-children \"$file\" \"$heading_escaped\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_get() {
    local file="$1"
    local heading="$2"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading name required"

    # Escape double quotes in heading for elisp string
    local heading_escaped="${heading//\"/\\\"}"

    local elisp="(progn
      (let ((result (org-batch-get-todo-content \"$file\" \"$heading_escaped\")))
        (if result
            (org-batch-output-json t result)
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_overdue() {
    local file="$1"

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp="(progn
      (let ((result (org-batch-get-overdue \"$file\")))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_upcoming() {
    local file="$1"; shift
    local days=7

    [[ -f "$file" ]] || error "File not found: $file"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --days=*)
                days=$(parse_option "$1" "--days=")
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    local elisp="(progn
      (let ((result (org-batch-get-upcoming \"$file\" $days)))
        (org-batch-output-json t result))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_add() {
    local file="$1"
    local heading="$2"; shift 2
    local section="" scheduled="" priority="" tags=""

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --section=*)
                section=$(parse_option "$1" "--section=")
                shift
                ;;
            --scheduled=*)
                scheduled=$(parse_option "$1" "--scheduled=")
                shift
                ;;
            --priority=*)
                priority=$(parse_option "$1" "--priority=")
                shift
                ;;
            --tags=*)
                tags=$(parse_option "$1" "--tags=")
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    [[ -n "$section" ]] || error "--section required"

    local elisp
    elisp="(progn
      (let ((result (org-batch-add-todo \"$file\" \"$section\" \"$heading\"
                      $([ -n "$scheduled" ] && echo "\"$scheduled\"" || echo "nil")
                      $([ -n "$priority" ] && echo "$priority" || echo "nil")
                      $([ -n "$tags" ] && echo "'(${tags//,/\" \"})" || echo "nil"))))
        (if result
            (org-batch-output-json t (list :added t :heading \"$heading\"))
          (org-batch-output-error \"Section not found: $section\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_update_state() {
    local file="$1"
    local heading="$2"
    local new_state="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$new_state" ]] || error "New state required"

    local elisp="(progn
      (let ((result (org-batch-update-state \"$file\" \"$heading\" \"$new_state\")))
        (if result
            (org-batch-output-json t (list :updated t :heading \"$heading\" :state \"$new_state\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_schedule() {
    local file="$1"
    local heading="$2"
    local date="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$date" ]] || error "Date required (YYYY-MM-DD)"

    local elisp="(progn
      (let ((result (org-batch-schedule-task \"$file\" \"$heading\" \"$date\")))
        (if result
            (org-batch-output-json t (list :scheduled t :heading \"$heading\" :date \"$date\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_deadline() {
    local file="$1"
    local heading="$2"
    local date="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$date" ]] || error "Date required (YYYY-MM-DD)"

    local elisp="(progn
      (let ((result (org-batch-set-deadline \"$file\" \"$heading\" \"$date\")))
        (if result
            (org-batch-output-json t (list :deadline t :heading \"$heading\" :date \"$date\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_priority() {
    local file="$1"
    local heading="$2"
    local priority="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$priority" ]] || error "Priority required (1-5)"

    local elisp="(progn
      (let ((result (org-batch-set-priority \"$file\" \"$heading\" $priority)))
        (if result
            (org-batch-output-json t (list :priority t :heading \"$heading\" :value $priority))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_archive() {
    local file="$1"

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp="(progn
      (let ((count (org-batch-archive-done \"$file\")))
        (org-batch-output-json t (list :archived count)))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

# Tag management commands

cmd_add_tags() {
    local file="$1"
    local heading="$2"
    local tags="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$tags" ]] || error "Tags required (comma-separated)"

    # Convert comma-separated tags to quoted elisp list
    local tags_list
    tags_list="'($(echo "$tags" | sed 's/,/ /g' | sed 's/\([^ ]*\)/"\1"/g'))"

    local elisp="(progn
      (let ((result (org-batch-add-tags \"$file\" \"$heading\" $tags_list)))
        (if result
            (org-batch-output-json t (list :tags-added t :heading \"$heading\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_remove_tags() {
    local file="$1"
    local heading="$2"
    local tags="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$tags" ]] || error "Tags required (comma-separated)"

    # Convert comma-separated tags to quoted elisp list
    local tags_list
    tags_list="'($(echo "$tags" | sed 's/,/ /g' | sed 's/\([^ ]*\)/"\1"/g'))"

    local elisp="(progn
      (let ((result (org-batch-remove-tags \"$file\" \"$heading\" $tags_list)))
        (if result
            (org-batch-output-json t (list :tags-removed t :heading \"$heading\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_replace_tags() {
    local file="$1"
    local heading="$2"
    local tags="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$tags" ]] || error "Tags required (comma-separated)"

    # Convert comma-separated tags to quoted elisp list
    local tags_list
    tags_list="'($(echo "$tags" | sed 's/,/ /g' | sed 's/\([^ ]*\)/"\1"/g'))"

    local elisp="(progn
      (let ((result (org-batch-replace-tags \"$file\" \"$heading\" $tags_list)))
        (if result
            (org-batch-output-json t (list :tags-replaced t :heading \"$heading\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_list_tags() {
    local file="$1"

    [[ -f "$file" ]] || error "File not found: $file"

    local elisp="(progn
      (let ((tags (org-batch-list-all-tags \"$file\")))
        (org-batch-output-json t tags))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

# Property operations commands

cmd_get_property() {
    local file="$1"
    local heading="$2"
    local property="$3"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$property" ]] || error "Property name required"

    local elisp="(progn
      (let ((value (org-batch-get-property \"$file\" \"$heading\" \"$property\")))
        (if value
            (org-batch-output-json t (list :property \"$property\" :value value))
          (org-batch-output-error \"Property not found or heading not found\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_set_property() {
    local file="$1"
    local heading="$2"
    local property="$3"
    local value="$4"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"
    [[ -n "$property" ]] || error "Property name required"
    [[ -n "$value" ]] || error "Property value required"

    local elisp="(progn
      (let ((result (org-batch-set-property \"$file\" \"$heading\" \"$property\" \"$value\")))
        (if result
            (org-batch-output-json t (list :property-set t :property \"$property\" :value \"$value\"))
          (org-batch-output-error \"Heading not found: $heading\")))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

cmd_list_properties() {
    local file="$1"
    local heading="$2"

    [[ -f "$file" ]] || error "File not found: $file"
    [[ -n "$heading" ]] || error "Heading required"

    local elisp="(progn
      (let ((props (org-batch-list-properties \"$file\" \"$heading\")))
        (org-batch-output-json t props))
      (kill-emacs 0))"

    run_elisp "$elisp"
}

# Denote commands

cmd_denote_create() {
    local title="$1"
    local tags="$2"; shift 2
    local signature="" category="" directory="" content_file=""

    [[ -n "$title" ]] || error "Title required"
    [[ -n "$tags" ]] || error "Tags required (comma-separated)"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --signature=*)
                signature=$(parse_option "$1" "--signature=")
                shift
                ;;
            --category=*)
                category=$(parse_option "$1" "--category=")
                shift
                ;;
            --directory=*)
                directory=$(parse_option "$1" "--directory=")
                shift
                ;;
            --content=*)
                content_file=$(parse_option "$1" "--content=")
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    # Convert comma-separated tags to elisp list
    local tags_list="'(${tags//,/ })"

    # Build elisp call
    local elisp="(progn"

    if [[ -n "$content_file" ]]; then
        [[ -f "$content_file" ]] || error "Content file not found: $content_file"
        elisp="$elisp
      (denote-batch-create-note-from-file
        \"$title\"
        $tags_list
        \"$content_file\""
    else
        elisp="$elisp
      (denote-batch-create-note
        \"$title\"
        $tags_list"
    fi

    # Add optional parameters
    [[ -n "$signature" ]] && elisp="$elisp
        \"$signature\"" || elisp="$elisp
        nil"
    [[ -n "$category" ]] && elisp="$elisp
        \"$category\"" || elisp="$elisp
        nil"
    [[ -n "$directory" ]] && elisp="$elisp
        \"$directory\"" || elisp="$elisp
        nil"

    elisp="$elisp)
      (kill-emacs 0))"

    run_denote_elisp "$elisp"
}

cmd_denote_append() {
    local filepath="$1"
    local content_file="$2"

    [[ -f "$filepath" ]] || error "File not found: $filepath"
    [[ -f "$content_file" ]] || error "Content file not found: $content_file"

    # Read content
    local content
    content=$(<"$content_file")

    # Escape quotes for elisp
    content="${content//\"/\\\"}"

    local elisp="(progn
      (denote-batch-append-content \"$filepath\" \"$content\")
      (kill-emacs 0))"

    run_denote_elisp "$elisp"
}

cmd_denote_metadata() {
    local filepath="$1"

    [[ -f "$filepath" ]] || error "File not found: $filepath"

    local elisp="(progn
      (denote-batch-read-metadata \"$filepath\")
      (kill-emacs 0))"

    run_denote_elisp "$elisp"
}

cmd_denote_update() {
    local filepath="$1"; shift
    local new_title="" new_tags="" new_category=""

    [[ -f "$filepath" ]] || error "File not found: $filepath"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --title=*)
                new_title=$(parse_option "$1" "--title=")
                shift
                ;;
            --tags=*)
                new_tags=$(parse_option "$1" "--tags=")
                shift
                ;;
            --category=*)
                new_category=$(parse_option "$1" "--category=")
                shift
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    # Convert tags if provided
    local tags_list="nil"
    [[ -n "$new_tags" ]] && tags_list="'(${new_tags//,/ })"

    # shellcheck disable=SC2155
    local elisp="(progn
      (denote-batch-update-frontmatter \"$filepath\"
        $([ -n "$new_title" ] && echo "\"$new_title\"" || echo "nil")
        $tags_list
        $([ -n "$new_category" ] && echo "\"$new_category\"" || echo "nil"))
      (kill-emacs 0))"

    run_denote_elisp "$elisp"
}

# Main
main() {
    check_deps

    if [[ $# -eq 0 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        usage
    fi

    local command="$1"; shift

    case "$command" in
        list)
            cmd_list "$@"
            ;;
        scheduled)
            cmd_scheduled "$@"
            ;;
        count)
            cmd_count "$@"
            ;;
        search)
            cmd_search "$@"
            ;;
        by-section)
            cmd_by_section "$@"
            ;;
        sections)
            cmd_sections "$@"
            ;;
        children)
            cmd_children "$@"
            ;;
        get)
            cmd_get "$@"
            ;;
        overdue)
            cmd_overdue "$@"
            ;;
        upcoming)
            cmd_upcoming "$@"
            ;;
        add)
            cmd_add "$@"
            ;;
        update-state)
            cmd_update_state "$@"
            ;;
        schedule)
            cmd_schedule "$@"
            ;;
        deadline)
            cmd_deadline "$@"
            ;;
        priority)
            cmd_priority "$@"
            ;;
        archive)
            cmd_archive "$@"
            ;;
        add-tags)
            cmd_add_tags "$@"
            ;;
        remove-tags)
            cmd_remove_tags "$@"
            ;;
        replace-tags)
            cmd_replace_tags "$@"
            ;;
        list-tags)
            cmd_list_tags "$@"
            ;;
        get-property)
            cmd_get_property "$@"
            ;;
        set-property)
            cmd_set_property "$@"
            ;;
        list-properties)
            cmd_list_properties "$@"
            ;;
        denote-create)
            cmd_denote_create "$@"
            ;;
        denote-append)
            cmd_denote_append "$@"
            ;;
        denote-metadata)
            cmd_denote_metadata "$@"
            ;;
        denote-update)
            cmd_denote_update "$@"
            ;;
        *)
            error "Unknown command: $command. Use --help for usage."
            ;;
    esac
}

main "$@"
